#include <Wire.h>
#include <Adafruit_PWMServoDriver.h>

// COXA - FEMUR - TIBIA

#define SERVOMIN  120 // this is the 'minimum' pulse length count (out of 4096)
#define SERVOMAX  580 // this is the 'maximum' pulse length count (out of 4096)
boolean sobe = 0 ;
Adafruit_PWMServoDriver pwm = Adafruit_PWMServoDriver(); // the servo
//
//class Sweeper {
//
//
//	int srvn ;
//	int degreeMin ;
//	int degreeMax ;
//	boolean direc ;
//	int pos = 90; // current servo position
//	int increment; // increment to move for each interval
//	int updateInterval; // interval between updates
//	unsigned long lastUpdate; // last update of position
//
//	public:
//	Sweeper(int servo, boolean dir , int degrMin, int degrMax , int interval) {
//		updateInterval = interval;
//		increment = 1;
//		srvn = servo;
//		degreeMin = degrMin ;
//		degreeMax = degrMax ;
//		direc = dir;
//	}
//
//	void Attach(){
//		//servo.attach(pin);
//		moveServo(srvn, 90);
//		delay(1000);
//	}
//
//	void Detach() {
//		//servo.detach();
//	}
//
//	void moveServo(int servo, int angle) {
//	    int pulselength = map(angle, 0, 180, SERVOMIN, SERVOMAX);
//	    pwm.setPWM(servo, 0, pulselength);
//	}
//
//	void Update() {
//		// CADA VEZ QUE ENTRA AQUI INCREMENTA EM UM, EH COMO SE FOSE UM FOR BASEADO EM TEMPO (INTERVAL)
//		if((millis() - lastUpdate) > updateInterval){ // time to update
//
//			lastUpdate = millis();
//
//			if (direc) {
//				//degreeMin += increment;
//				if (pos < degreeMax){
//					pos += increment;
//					moveServo(srvn,pos);
//
//				}
//			} else {
//				if (pos > degreeMin ){
//					pos -= increment;
//					moveServo(srvn,pos);
//				}
//			}
//
//			//moveServo(srvn,pos);
//			Serial.println(pos);
//
////			if ((pos >= 180) || (pos <= 0)){ // end of sweep
////				// reverse direction
////				increment = -increment;
////			}
//		}
//	}
//};
//
//class SweeperFF {
//
//
//	int srvn ;
//	int degreeMin ;
//	int degreeMax ;
//	boolean direc ;
//	int pos = 90; // current servo position
//	int increment; // increment to move for each interval
//	int updateInterval; // interval between updates
//	unsigned long lastUpdate; // last update of position
//
//	public:
//	SweeperFF(int servo, boolean dir , int degrMin, int degrMax , int interval) {
//		updateInterval = interval;
//		increment = 1;
//		srvn = servo;
//		degreeMin = degrMin ;
//		degreeMax = degrMax ;
//		direc = dir;
//	}
//
//	void Attach(){
//		//servo.attach(pin);
//		moveServo(srvn, 90);
//		delay(1000);
//	}
//
//	void Detach() {
//		//servo.detach();
//	}
//
//	void moveServo(int servo, int angle) {
//	    int pulselength = map(angle, 0, 180, SERVOMIN, SERVOMAX);
//	    pwm.setPWM(servo, 0, pulselength);
//	}
//
//	void Update() {
//		// CADA VEZ QUE ENTRA AQUI INCREMENTA EM UM, EH COMO SE FOSE UM FOR BASEADO EM TEMPO (INTERVAL)
//		if((millis() - lastUpdate) > updateInterval){ // time to update
//
//			lastUpdate = millis();
//
//			if (direc) {
//				//degreeMin += increment;
//				if (pos < degreeMax){
//					pos += increment;
//					moveServo(srvn,pos);
//
//				} else {
//					direc = 0 ;
//				}
//			} else {
//				if (pos > degreeMin ){
//					pos -= increment;
//					moveServo(srvn,pos);
//				} else {
//					direc = 1 ;
//				}
//			}
//
//			//moveServo(srvn,pos);
//			Serial.println(pos);
//
////			if ((pos >= 180) || (pos <= 0)){ // end of sweep
////				// reverse direction
////				increment = -increment;
////			}
//		}
//	}
//};
//
//class MultiThread {
//
//
//	int srvn ;
//	int degreeMin ;
//	int degreeMax ;
//	boolean direc ;
//	boolean fflop ;
//	int pos = 90; // current servo position
//	int increment; // increment to move for each interval
//	int updateInterval; // interval between updates
//	unsigned long lastUpdate; // last update of position
//
//	public:
//	MultiThread(int servo, boolean ff , boolean dir , int degrMin, int degrMax , int interval) {
//		updateInterval = interval;
//		increment = 1;
//		srvn = servo;
//		degreeMin = degrMin ;
//		degreeMax = degrMax ;
//		direc = dir;
//		fflop = ff;
//	}
//
//	void RedefineThreadInterval(int interval){
//		updateInterval = interval;
//	}
//
//	void init(){
//		//servo.attach(pin);
//		moveServo(srvn, 90);
//		delay(1000);
//	}
//
//	void Detach() {
//		//servo.detach();
//	}
//
//	void moveServo(int servo, int angle) {
//	    int pulselength = map(angle, 0, 180, SERVOMIN, SERVOMAX);
//	    pwm.setPWM(servo, 0, pulselength);
//	}
//
//	void Update() {
//		// CADA VEZ QUE ENTRA AQUI INCREMENTA EM UM, EH COMO SE FOSE UM FOR BASEADO EM TEMPO (INTERVAL)
//		if((millis() - lastUpdate) > updateInterval){ // time to update
//
//			lastUpdate = millis();
//
//			if (direc) {
//				//degreeMin += increment;
//				if (pos < degreeMax){
//					pos += increment;
//					moveServo(srvn,pos);
//
//				} else {
//					if (fflop) direc = 0 ;
//
//				}
//			} else {
//				if (pos > degreeMin ){
//					pos -= increment;
//					moveServo(srvn,pos);
//				} else {
//					if (fflop) direc = 1 ;
//
//				}
//			}
//
//			//moveServo(srvn,pos);
//			//Serial.println(pos);
//
////			if ((pos >= 180) || (pos <= 0)){ // end of sweep
////				// reverse direction
////				increment = -increment;
////			}
//		}
//	}
//};


class Pata {


	int coxa ;
	int femur ;
	int tibia ;
	int coxaDegrMin ;
	int coxaDegrMax ;
	int femurDegrMin ;
	int femurDegrMax ;
	int tibiaDegrMin ;
	int tibiaDegrMax ;
	int patan ;
	int pataOffSet [4][3] = {{0,0,0},{30,-5,0},{0,0,0},{80,0,0}};
	//		   Pata N        {coxa,femur,tibia}
	boolean dir ;
	boolean fflop ;
	int pos = 90; // current servo position
	int increment; // increment to move for each interval
	int updateInterval; // interval between updates
	unsigned long lastUpdate; // last update of position

	public:
	Pata(int Patan , int Coxa, int Femur, int Tibia, boolean FF , boolean Dir , int CoxaDegrMin, int CoxaDegrMax , int FemurDegrMin , int FemurDegrMax, int TibiaDegrMin, int TibiaDegrMax, int interval) {
		updateInterval = interval; //tempo em ms que o servo será atualizado em um grau
		increment = 1; // De quantos em quantos graus será incrmentado o servo
		patan = Patan ;
		coxa = Coxa  ;
		femur = Femur ;
		tibia = Tibia ;
		dir = Dir;
		fflop = FF;
		coxaDegrMin  = CoxaDegrMin  + pataOffSet [patan] [0];
		coxaDegrMax  = CoxaDegrMax  + pataOffSet [patan] [0];
		femurDegrMin = FemurDegrMin + pataOffSet [patan] [1];
		femurDegrMax = FemurDegrMax + pataOffSet [patan] [1];
		tibiaDegrMin = TibiaDegrMin + pataOffSet [patan] [2];
		tibiaDegrMax = TibiaDegrMax + pataOffSet [patan] [2];

	}

	void RedefineThreadInterval(int interval){
		updateInterval = interval;
	}

	void init(){
		//servo.attach(pin);
		moveServo(coxa,  coxaDegrMax);
		moveServo(femur, femurDegrMax);
		moveServo(tibia, tibiaDegrMax);

			if ( dir == 0 ){
				pos = coxaDegrMax ;
			} else {
				pos = coxaDegrMin ;
			}

			if ( patan == 1 ) pos = pos + 75 ;
			if ( patan == 2 ) pos = pos + 25 ;
			if ( patan == 3 ) pos = pos + 50 ;

		delay(1000);
	}

	void Detach() {
		//servo.detach();
	}

	void moveServo(int servo, int angle) {
	    int pulselength = map(angle, 0, 180, SERVOMIN, SERVOMAX);
	    pwm.setPWM(servo, 0, pulselength);
	}

	void Update() {
		// CADA VEZ QUE ENTRA AQUI INCREMENTA EM UM, EH COMO SE FOSE UM FOR BASEADO EM TEMPO (INTERVAL)
		//Serial.println("==============================================");
		//Serial.print("Incio -->");
		//Serial.print(patan);
		//Serial.print("<-->");
		//Serial.print(pos);
		//Serial.println("<--");
		if((millis() - lastUpdate) > updateInterval){ // time to update

			lastUpdate = millis();
			/*
			 * Coxa para Frente
			 */
			if (dir) {
				//degreeMin += increment;
				if (pos < coxaDegrMax){
					pos += increment;
					moveServo(coxa, pos);
					//Serial.println("=========== move coxa ========================");
					//Serial.print(patan); Serial.print(" <==> ") ;Serial.print(coxa);Serial.print(" <==> ");Serial.println(pos);
					//Serial.println("=========== move coxa ========================");
				} else {
					if (fflop) dir = 0 ;
					// Sobe Femur
					moveServo(femur, femurDegrMin);//100);
					moveServo(tibia, tibiaDegrMin);//70);

				}
			/*
			 * Coxa para tras
			 */
			} else {
				if (pos > coxaDegrMin ){
					pos -= increment;
					moveServo(coxa, pos);
				} else {
					if (fflop) dir = 1 ;
					// Abaixa femur
					moveServo(femur, femurDegrMax);
					moveServo(tibia, tibiaDegrMax);

				}
			}
		}
	}
};



//Sweeper sweeper1(0, 1, 45, 135, 1);
//SweeperFF sweeper1(0, 1, 45, 135, 10);
//MultiThread thread0_Dir_Coxa (0, 1, 1, 45, 135, 20);
//MultiThread thread1_Dir_Femur(1, 1, 1, 45, 135, 10);
//MultiThread thread2_Dir_Tibia(2, 1, 1, 45, 135, 10);

Pata pata0_Dir_frt(0,  0, 1, 2, 1, 1, 35,110, 80,150, 50,100, 20);
Pata pata1_Dir_trs(1,  4, 5, 6, 1, 1, 35,110, 80,150, 50,100, 20);
Pata pata2_Esq_trs(2,  8, 9,10, 1, 1,  0, 75, 30,80,  80,130, 20);
Pata pata3_Esq_frt(3, 12,13,14, 1, 1,  0, 75, 30,80,  80,130, 20);
//Sweeper sweeper2(0, 0, 45, 135, 50);
//Sweeper sweeper2(3, 50);
//Sweeper sweeper3(4, 50);



void setup() {
	Serial.begin(9600);
	pwm.begin();
	pwm.setPWMFreq(60);  // Analog servos run at ~60 Hz updates
	pata0_Dir_frt.init();
	pata1_Dir_trs.init();
	pata2_Esq_trs.init();
	pata3_Esq_frt.init();
}

void loop(){
	//Serial.println("\nLoop\r");
	pata0_Dir_frt.Update();
	pata1_Dir_trs.Update();
	pata2_Esq_trs.Update();
	pata3_Esq_frt.Update();
}
